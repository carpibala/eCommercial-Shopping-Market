<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <title>3D Particle Christmas Tree</title>
    <style>
        html, body {
            margin: 0;
            height: 100%;
            background: #111;
            overflow: hidden;
            font-family: 仿宋, serif;
        }

        #text {
            position: absolute;
            text-align: center;
            top: 48px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 39px;
            color: #d881b2;
            text-shadow: 0 5px 10px rgb(255, 0, 157);
            z-index: 10;
            font-family: stxingkai, serif;
            font-weight: 100;
        }

        #btn-volume {
            position: fixed;
            top: 30px;
            right: 35px;
            width: 70px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: rgba(255, 255, 255, .15);
            color: #fff;
            font-size: 22px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background .2;
            z-index: 100;
        }
        #btn-volume:hover {
            background: rgba(255, 255, 255, .25);
        }
        #btn-volume.muted::after {
            content: '';
            position: absolute;
            width: 2px;
            height: 26px;
            background: #fff;
            transform: rotate(-45deg);
        }
        #footer {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 50px;
            text-align: center;
            z-index: 10;
            font-family: stxingkai, serif;
}
    </style>
</head>

<body>
    <div id="text">Merry Christmas</div>
    <!-- footer -->
    <div id="footer">By Joshua Z</div>
    <!-- 修正音频链接 -->
    <audio id="bgm" loop muted
        src='https://raw.githubusercontent.com/carpibala/-.-/main/M500002l8Lye30Tfcr.mp3'></audio>

    <button id="btn-volume" title="静音/开声">♪</button>

    <!-- 移除importmap，使用全局THREE -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // 将main.js的内容直接放在这里（移除import语句）
        /* ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― */
        // 1. 场景、相机、渲染器 初始化
        /* ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― */
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050515);

        const camera = new THREE.PerspectiveCamera(
            64,
            window.innerWidth / window.innerHeight,
            0.1,
            10000
        );
        camera.position.set(-28, -3, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        /* ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― */
        // 2. 实心圆润的粒子爱心
        /* ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― */
        function createHeart(size = 1.5) {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color = new THREE.Color('#edcad1');
            const particleCount = 3000;
            const edgeSoftness = 0.3;

            for (let i = 0; i < particleCount; i++) {
                const t = Math.random() * Math.PI * 2;
                const baseX = 16 * Math.pow(Math.sin(t), 3);
                const baseY = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                
                const scale = 0.3 + Math.random() * 0.7;
                let x = baseX * scale;
                let y = baseY * scale;
                
                if (Math.random() < edgeSoftness) {
                    x += (Math.random() - 0.5) * 1.2;
                    y += (Math.random() - 0.5) * 1.2;
                } else {
                    x += (Math.random() - 0.5) * 0.4;
                    y += (Math.random() - 0.5) * 0.4;
                }
                
                x = x * size / 16;
                y = y * size / 16;
                
                const z = (Math.random() - 0.5) * 0.3 * size;

                positions.push(x, y, z);
                
                const brightness = 0.9 - (scale * 0.3) + Math.random() * 0.2;
                colors.push(color.r * brightness, color.g * brightness, color.b * brightness);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.07 * size,
                vertexColors: true,
                transparent: true,
                opacity: 0.98,
                depthWrite: false
            });

            const heart = new THREE.Points(geometry, material);
            heart.position.y = 14.8 - (size * 0.8);
            return heart;
        }

        /* ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― */
        // 3. 圣诞树本体
        /* ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― */
        function createLayeredTree() {
            const pickColor = () => Math.random() < 0.6 ? '#f194a4' : '#FFFFFF';

            const layers = [
                { radius: 0.5,  height: 2,   count: 100, y: 14.8 },
                { radius: 1.79, height: 3.5, count: 300, y: 12   },
                { radius: 3,    height: 2.8, count: 500, y: 9    },
                { radius: 4.5,  height: 3,   count: 700, y: 6    },
                { radius: 6,    height: 3.5, count: 900, y: 3    },
                { radius: 7.5,  height: 4,   count: 1100, y: 0   },
                { radius: 9,    height: 4.5, count: 1300, y: -3  }
            ];

            const treeGeometry = new THREE.BufferGeometry();
            const allPoints = [];
            const allColors  = [];
            const color = new THREE.Color();

            layers.forEach(layer => {
                const { radius, height, count, y } = layer;

                for (let i = 0; i < count; i++) {
                    const t     = i / count;
                    const theta = t * 3 * Math.PI * 2;
                    const r     = radius * (0.5 + Math.random() * 0.5);
                    let x = r * Math.cos(theta);
                    let z = r * Math.sin(theta);
                    x += (Math.random() - 0.5) * 0.8;
                    z += (Math.random() - 0.5) * 0.8;
                    const yPos = y + (Math.random() - 0.5) * height;
                    allPoints.push(x, yPos, z);

                    color.set(pickColor());
                    allColors.push(color.r, color.g, color.b);
                }

                const twigCount = 30 + Math.floor(Math.random() * 21);
                for (let i = 0; i < twigCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const baseR = radius + 0.2;
                    const extend = 0.8 + Math.random() * 1.2;
                    const x = (baseR + extend) * Math.cos(angle) + (Math.random() - 0.5) * 0.4;
                    const z = (baseR + extend) * Math.sin(angle) + (Math.random() - 0.5) * 0.4;
                    const yPos = y + (Math.random() - 0.5) * height * 0.6;
                    allPoints.push(x, yPos, z);

                    color.set(pickColor());
                    allColors.push(color.r, color.g, color.b);
                }
            });

            const trunkHeight = 8;
            const trunkRadius = 1;
            const trunkCount = 500;
            for (let i = 0; i < trunkCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const r   = trunkRadius * (0.5 + Math.random() * 0.5);
                const x   = r * Math.cos(theta);
                const z   = r * Math.sin(theta);
                const y   = -3 - Math.random() * trunkHeight;
                allPoints.push(x, y, z);

                color.set(pickColor());
                allColors.push(color.r, color.g, color.b);
            }

            treeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(allPoints, 3));
            treeGeometry.setAttribute('color',    new THREE.Float32BufferAttribute(allColors,  3));

            const material = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                depthWrite: false
            });
            return new THREE.Points(treeGeometry, material);
        }

        /* ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― */
        // 4. 水波地面
        /* ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― */
        function createWaterRipples() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors    = [];
            const radii     = [];

            const maxRadius = 37;
            const totalParticles = 18000;
            const baseY = -8;

            for (let i = 0; i < totalParticles; i++) {
                const theta = Math.random() * Math.PI * 2;
                const r     = maxRadius * Math.random();
                const x     = r * Math.cos(theta);
                const z     = r * Math.sin(theta);
                const y     = baseY;
                positions.push(x, y, z);
                colors.push(1, 1, 1);
                radii.push(r);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color',    new THREE.Float32BufferAttribute(colors,    3));

            const material = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.85,
                depthWrite: false
            });

            const ripples = new THREE.Points(geometry, material);
            ripples.userData = {
                radii,
                waveSpeed: 0.4,
                waveHeight: 0.4,
                waveLength: 3
            };
            return ripples;
        }
        /* ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― */
        // 5. 星空背景
        /* ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― */
        function createStars() {
            const geometry = new THREE.BufferGeometry();
            const points  = [];
            const colors  = [];
            const color   = new THREE.Color();
            const starCount = 8000;

            for (let i = 0; i < starCount; i++) {
                const x = (Math.random() - 0.5) * 300;
                const y = (Math.random() - 0.5) * 300;
                const z = (Math.random() - 0.5) * 300;
                points.push(x, y, z);

                const brightness = 0.6 + Math.random() * 0.4;
                color.setRGB(brightness, brightness, brightness);
                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            geometry.setAttribute('color',    new THREE.Float32BufferAttribute(colors,  3));
            return new THREE.Points(geometry, new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true
            }));
        }

        /* ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― */
        // 6. 场景组合 & 动画
        /* ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― */
        const tree     = createLayeredTree();
        const ripples  = createWaterRipples();
        const stars    = createStars();
        const heart    = createHeart(1.5);

        heart.position.set(0, 17, 0);

        tree.add(heart);
        scene.add(tree);
        scene.add(ripples);
        scene.add(stars);

        function animate() {
            requestAnimationFrame(animate);
            tree.rotation.y += 0.005;

            const posAttr = ripples.geometry.attributes.position;
            const { radii, waveSpeed, waveHeight, waveLength } = ripples.userData;
            const time = performance.now() * 0.0005;

            for (let i = 0; i < posAttr.count; i++) {
                const r = radii[i];
                const wave = Math.sin((time * waveSpeed - r / waveLength) * Math.PI * 2) * waveHeight;
                posAttr.setY(i, -11 + wave);
            }
            posAttr.needsUpdate = true;

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>

    <!-- 音乐控制脚本 -->
    <script>
        const bgm = document.getElementById('bgm');
        const btn = document.getElementById('btn-volume');

        let ready = false;

        function firstActivate() {
            if (ready) return;
            bgm.muted = false;
            bgm.volume = 0.6;
            bgm.play()
                .then(() => { ready = true; })
                .catch(err => {
                    console.warn('播放失败:', err);
                });
            document.removeEventListener('click', firstActivate, { once: true });
            document.removeEventListener('keydown', firstActivate, { once: true });
        }

        document.addEventListener('click', firstActivate, { once: true });
        document.addEventListener('keydown', firstActivate, { once: true });

        btn.onclick = () => {
            if (!ready) {
                firstActivate();
                return;
            }
            bgm.muted = !bgm.muted;
            btn.classList.toggle('muted', bgm.muted);
        };
    </script>
</body>
</html>